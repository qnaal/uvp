(defun spring (k x &optional (v 0) (c 1))
  "returnes force for a damped spring-mass system"
  (- (* (- k) x)
     (* c v)))

;; (defun acceleration-constant (everyone state-lst acc-pol-lst t1)
;;   "returns constant acceleration along x-axis"
;;   (declare (ignore state-lst acc-pol-lst t1))
;;   (let ((accel-lst))
;;     (dotimes (i (length everyone) accel-lst)
;;       (push '(1/2 0) accel-lst))))

;; called by 'evaluate-deriv' four times per physics-loop
(defun acceleration (everyone state-lst acc-pol-lst t1)
  "returns everyone's acceleration"
  (declare (ignore t1 acc-pol-lst))
  (let ((force-collision-plst (collision-resolve everyone
						 (let ((pos-lst))
						   (dolist (state state-lst (nreverse pos-lst))
						     (push (car state) pos-lst)))
						 (let ((vel-lst))
						   (dolist (state state-lst (nreverse vel-lst))
						     (push (cadr state) vel-lst)))
						 *map*))
	(accel-lst))
    (dotimes (i (length everyone) accel-lst)
      (let* ((guy (nth i everyone))	;FIXME: this monstrosity has to be against some sort of rule
	     (force-collision (or (getf force-collision-plst guy) (make-pt)))

	     (mass (attribute guy :mass))
	     (size (attribute guy :size))
	     (leg-str (attribute guy :leg-str))
	     (accelk (attribute guy :accelk))
	     ;; (spd-max (* leg-str (/ mass))))
	     (spd-max (* leg-str size (/ mass)))
	     (run (get-run guy))
	     (run-r (pt-pol-r run))
	     (run-theta (pt-pol-theta run))

	     (state (nth i state-lst))
	     ;; (pos (first state))
	     (vel-current (second state))
	     (target-r (* spd-max run-r))
	     (vel-target (carterize (make-pt-pol target-r run-theta)))
	     (vel-diff (v- vel-current vel-target))
	     (vel-diff-pol (polarize vel-diff))
	     (vel-diff-r (pt-pol-r vel-diff-pol))
	     (vel-diff-theta (pt-pol-theta vel-diff-pol))
	     (force-input-pol (make-pt-pol (spring accelk vel-diff-r)
					   vel-diff-theta))
	     (force-input (carterize force-input-pol))
	     (force-total (v+ force-input force-collision))
	     (acc1 (v* (/ mass) force-total)))
	(setf accel-lst (append accel-lst (list acc1)))))))

(defun test-acc (everyone times)
  (let ((state-lst))
    (dolist (guy everyone)
      (let ((state (list (attribute guy :pos)
			 (carterize (attribute guy :vel-pol)))))
	(setf state-lst (append state-lst (list state)))))
    (dotimes (i times)
      (acceleration everyone state-lst () ()))))

;; (defun acceleration-dumb (everyone state-lst acc-pol-lst t1)
;;   "returns everyone's acceleration"
;;   (declare (ignore t1 state-lst acc-pol-lst))
;;   (let ((accel-lst))
;;     (dotimes (i (length everyone) accel-lst)
;;       (let* ((guy (nth i everyone))
;; 	     (acc-spd (attribute guy :acc-spd))
;; 	     (leg-str (attribute guy :leg-str))
;; 	     (mass (attribute guy :mass))
;; 	     (size (attribute guy :size))
;; 	     (spd-max (* leg-str size (/ mass)))
;; 	     (acc-max (* leg-str (/ mass)))
;; 	     (vel-current (carterize (attribute guy :vel-pol))))
;; 	(destructuring-bind (run-r run-theta)
;; 	    (get-run guy)
;; 	  (let* ((target-r (* spd-max run-r))
;; 		 (vel-target (carterize (list target-r run-theta)))
;; 		 (vel-diff (v- vel-target vel-current))
;; 		 (vel-diff-pol (polarize vel-diff))
;; 		 (acc1-pol (list (* acc-max acc-spd (/ (car vel-diff-pol)
;; 					       spd-max))
;; 				 (cadr vel-diff-pol)))
;; 		 (acc1 (carterize acc1-pol)))
;; 	    (setf accel-lst (append accel-lst (list acc1)))))))))
